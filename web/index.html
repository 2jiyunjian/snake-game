<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="description" content="ç»å…¸è´ªåƒè›‡æ¸¸æˆç½‘é¡µç‰ˆ - å…è´¹åœ¨çº¿ç©" />
  <title>è´ªåƒè›‡æ¸¸æˆ - Snake Game</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial,
        "Noto Sans", "Microsoft YaHei", sans-serif;
      background: radial-gradient(circle at top, #1f2933, #020617);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #e5e7eb;
    }

    .container {
      background: rgba(15, 23, 42, 0.95);
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
      padding: 24px 28px 20px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      max-width: 680px;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    .title {
      font-size: 24px;
      font-weight: 600;
      letter-spacing: 0.04em;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #10b981;
    }

    .score-status {
      display: flex;
      gap: 16px;
      align-items: center;
      font-size: 16px;
    }

    .score {
      font-weight: 600;
      color: #fbbf24;
    }

    .status {
      padding: 4px 12px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
    }

    .status.playing {
      background: #10b98144;
      color: #34d399;
    }

    .status.paused {
      background: #f59e0b44;
      color: #fbbf24;
    }

    .status.gameover {
      background: #ef444444;
      color: #f87171;
    }

    /* è®¾ç½®è¡Œæ ·å¼ */
    .settings-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    /* éš¾åº¦é€‰æ‹©æ ·å¼ */
    .selector-box {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(30, 41, 59, 0.6);
      padding: 8px 14px;
      border-radius: 8px;
    }

    .selector-label {
      font-size: 14px;
      color: #94a3b8;
    }

    .selector-buttons {
      display: flex;
      gap: 6px;
    }

    .sel-btn {
      padding: 6px 14px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.2s ease;
      background: rgba(71, 85, 105, 0.5);
      color: #94a3b8;
    }

    .sel-btn:hover {
      background: rgba(71, 85, 105, 0.8);
      color: #e5e7eb;
    }

    .sel-btn.active {
      color: #fff;
    }

    .sel-btn.easy.active {
      background: #10b981;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.4);
    }

    .sel-btn.hard.active {
      background: #ef4444;
      box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
    }

    .sel-btn.godmode.active {
      background: linear-gradient(135deg, #8b5cf6, #ec4899);
      box-shadow: 0 2px 12px rgba(139, 92, 246, 0.5);
      animation: godPulse 2s ease-in-out infinite;
    }

    @keyframes godPulse {
      0%, 100% { box-shadow: 0 2px 12px rgba(139, 92, 246, 0.5); }
      50% { box-shadow: 0 2px 20px rgba(236, 72, 153, 0.7); }
    }

    .sel-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .game-wrapper {
      position: relative;
      display: inline-block;
    }

    canvas {
      border: 2px solid #334155;
      border-radius: 8px;
      display: block;
      background: #0f172a;
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4);
    }

    canvas.godmode {
      border-color: #8b5cf6;
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.4), 0 0 20px rgba(139, 92, 246, 0.3);
    }

    .overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.85);
      border-radius: 8px;
      gap: 16px;
      pointer-events: none;
    }

    .overlay.hidden {
      display: none;
    }

    .overlay-title {
      font-size: 36px;
      font-weight: 700;
      color: #10b981;
      text-shadow: 0 2px 10px rgba(16, 185, 129, 0.5);
    }

    .overlay-title.godmode {
      background: linear-gradient(135deg, #8b5cf6, #ec4899);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .overlay-text {
      font-size: 18px;
      color: #e5e7eb;
    }

    .overlay-hint {
      font-size: 14px;
      color: #94a3b8;
      margin-top: 8px;
    }

    .overlay-mode {
      font-size: 15px;
      padding: 6px 16px;
      border-radius: 20px;
      margin-top: 4px;
    }

    .overlay-mode.easy {
      background: #10b98133;
      color: #34d399;
    }

    .overlay-mode.hard {
      background: #ef444433;
      color: #f87171;
    }

    .overlay-mode.godmode {
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(236, 72, 153, 0.3));
      color: #e879f9;
    }

    .controls {
      background: rgba(30, 41, 59, 0.6);
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 14px;
      color: #cbd5e1;
      line-height: 1.8;
    }

    .controls strong {
      color: #10b981;
    }

    .controls .key {
      display: inline-block;
      background: rgba(71, 85, 105, 0.6);
      padding: 2px 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
      color: #e5e7eb;
      margin: 0 2px;
    }

    @media (max-width: 680px) {
      .container {
        padding: 16px;
      }

      canvas {
        width: 100%;
        height: auto;
      }

      .title {
        font-size: 20px;
      }

      .score-status {
        font-size: 14px;
        gap: 12px;
      }

      .header {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }

      .settings-row {
        width: 100%;
      }

      .selector-box {
        flex: 1;
        justify-content: space-between;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1 class="title">ğŸ è´ªåƒè›‡</h1>
      <div class="score-status">
        <div class="score">åˆ†æ•°: <span id="score">0</span></div>
        <div class="status playing" id="status">è¿›è¡Œä¸­</div>
      </div>
    </div>

    <div class="settings-row">
      <div class="selector-box">
        <span class="selector-label">éš¾åº¦:</span>
        <div class="selector-buttons">
          <button class="sel-btn easy active" id="easyBtn" onclick="setDifficulty('easy')">ğŸŒ± ç®€å•</button>
          <button class="sel-btn hard" id="hardBtn" onclick="setDifficulty('hard')">ğŸ”¥ å›°éš¾</button>
        </div>
      </div>
      <div class="selector-box">
        <span class="selector-label">æ¨¡å¼:</span>
        <div class="selector-buttons">
          <button class="sel-btn godmode" id="godmodeBtn" onclick="toggleGodMode()">â­ æ— æ•Œæ¨¡å¼</button>
        </div>
      </div>
    </div>

    <div class="game-wrapper">
      <canvas id="gameCanvas" width="600" height="600"></canvas>
      <div class="overlay" id="overlay">
        <div class="overlay-title">è´ªåƒè›‡</div>
        <div class="overlay-text">æŒ‰ç©ºæ ¼é”®å¼€å§‹æ¸¸æˆ</div>
        <div class="overlay-hint">ä½¿ç”¨æ–¹å‘é”®æˆ– WASD æ§åˆ¶è›‡çš„ç§»åŠ¨</div>
      </div>
    </div>

    <div class="controls">
      <strong>æ“ä½œè¯´æ˜ï¼š</strong>ä½¿ç”¨ <span class="key">â†‘â†“â†â†’</span> æˆ– <span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> æ§åˆ¶è›‡ç§»åŠ¨ï¼Œ<span class="key">ç©ºæ ¼</span> å¼€å§‹/æš‚åœ/é‡æ–°å¼€å§‹<br>
      <strong>éš¾åº¦è¯´æ˜ï¼š</strong><strong style="color: #34d399;">ç®€å•</strong> è›‡ç§»åŠ¨è¾ƒæ…¢ï¼Œ<strong style="color: #f87171;">å›°éš¾</strong> è›‡ç§»åŠ¨å¾ˆå¿«<br>
      <strong>æ— æ•Œæ¨¡å¼ï¼š</strong><strong style="color: #e879f9;">å¯ç©¿å¢™ã€å¯ç©¿è¿‡è‡ªå·±</strong>ï¼ˆä»ä¸€è¾¹å‡ºå»ä¼šä»å¦ä¸€è¾¹å‡ºæ¥ï¼‰
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const statusElement = document.getElementById('status');
    const overlay = document.getElementById('overlay');
    const easyBtn = document.getElementById('easyBtn');
    const hardBtn = document.getElementById('hardBtn');
    const godmodeBtn = document.getElementById('godmodeBtn');

    const UNIT_SIZE = 25;
    const BOARD_WIDTH = canvas.width;
    const BOARD_HEIGHT = canvas.height;

    // éš¾åº¦è®¾ç½®
    const DIFFICULTY_SETTINGS = {
      easy: {
        delay: 150,
        name: 'ç®€å•æ¨¡å¼',
        color: '#34d399'
      },
      hard: {
        delay: 60,
        name: 'å›°éš¾æ¨¡å¼',
        color: '#f87171'
      }
    };

    let currentDifficulty = 'easy';
    let currentDelay = DIFFICULTY_SETTINGS.easy.delay;
    let godMode = false; // æ— æ•Œæ¨¡å¼

    let snake = [];
    let food = null;
    let direction = 'RIGHT';
    let nextDirection = 'RIGHT';
    let running = false;
    let paused = false;
    let score = 0;
    let gameLoop = null;
    let gameStarted = false;

    function setDifficulty(difficulty) {
      if (running && !paused) return;

      currentDifficulty = difficulty;
      currentDelay = DIFFICULTY_SETTINGS[difficulty].delay;

      easyBtn.classList.toggle('active', difficulty === 'easy');
      hardBtn.classList.toggle('active', difficulty === 'hard');

      if (!gameStarted) {
        showStartOverlay();
      }
    }

    function toggleGodMode() {
      if (running && !paused) return;

      godMode = !godMode;
      godmodeBtn.classList.toggle('active', godMode);
      canvas.classList.toggle('godmode', godMode);

      if (!gameStarted) {
        showStartOverlay();
      }
    }

    function updateSettingsButtons(disabled) {
      easyBtn.disabled = disabled;
      hardBtn.disabled = disabled;
      godmodeBtn.disabled = disabled;
    }

    function init() {
      snake = [
        { x: 0, y: 0 },
        { x: UNIT_SIZE, y: 0 },
        { x: UNIT_SIZE * 2, y: 0 }
      ];
      direction = 'RIGHT';
      nextDirection = 'RIGHT';
      running = false;
      paused = false;
      score = 0;
      gameStarted = false;
      updateScore();
      updateStatus('ready');
      updateSettingsButtons(false);
      generateFood();
      draw();
      showStartOverlay();
    }

    function showStartOverlay() {
      const diffSettings = DIFFICULTY_SETTINGS[currentDifficulty];
      const godModeText = godMode ? ' + æ— æ•Œæ¨¡å¼' : '';
      const titleClass = godMode ? 'overlay-title godmode' : 'overlay-title';
      
      overlay.innerHTML = `
        <div class="${titleClass}">è´ªåƒè›‡</div>
        <div class="overlay-mode ${currentDifficulty}">${diffSettings.name}${godModeText}</div>
        ${godMode ? '<div class="overlay-mode godmode">â­ ç©¿å¢™ + ç©¿èº«</div>' : ''}
        <div class="overlay-text">æŒ‰ç©ºæ ¼é”®å¼€å§‹æ¸¸æˆ</div>
        <div class="overlay-hint">ä½¿ç”¨æ–¹å‘é”®æˆ– WASD æ§åˆ¶è›‡çš„ç§»åŠ¨</div>
      `;
      overlay.classList.remove('hidden');
    }

    function startGame() {
      if (running && !paused) return;
      
      if (!running) {
        running = true;
        paused = false;
        gameStarted = true;
        hideOverlay();
        updateStatus('playing');
        updateSettingsButtons(true);
        gameLoop = setInterval(update, currentDelay);
      } else if (paused) {
        paused = false;
        hideOverlay();
        updateStatus('playing');
        updateSettingsButtons(true);
        gameLoop = setInterval(update, currentDelay);
      }
    }

    function pauseGame() {
      if (!running || paused) return;
      paused = true;
      clearInterval(gameLoop);
      updateStatus('paused');
      updateSettingsButtons(false);
      
      const diffSettings = DIFFICULTY_SETTINGS[currentDifficulty];
      const godModeText = godMode ? ' + æ— æ•Œ' : '';
      const titleClass = godMode ? 'overlay-title godmode' : 'overlay-title';
      
      overlay.innerHTML = `
        <div class="${titleClass}">æ¸¸æˆæš‚åœ</div>
        <div class="overlay-mode ${currentDifficulty}">${diffSettings.name}${godModeText}</div>
        <div class="overlay-text">æŒ‰ç©ºæ ¼é”®ç»§ç»­</div>
        <div class="overlay-hint">å¯åœ¨æš‚åœæ—¶åˆ‡æ¢éš¾åº¦å’Œæ¨¡å¼</div>
      `;
      overlay.classList.remove('hidden');
    }

    function restartGame() {
      clearInterval(gameLoop);
      init();
    }

    function update() {
      direction = nextDirection;
      move();
      
      if (checkCollision()) {
        gameOver();
        return;
      }

      if (checkFood()) {
        score++;
        updateScore();
        generateFood();
      }

      draw();
    }

    function move() {
      const head = { ...snake[snake.length - 1] };

      switch (direction) {
        case 'UP':
          head.y -= UNIT_SIZE;
          break;
        case 'DOWN':
          head.y += UNIT_SIZE;
          break;
        case 'LEFT':
          head.x -= UNIT_SIZE;
          break;
        case 'RIGHT':
          head.x += UNIT_SIZE;
          break;
      }

      // æ— æ•Œæ¨¡å¼ï¼šç©¿å¢™å¤„ç†
      if (godMode) {
        if (head.x < 0) head.x = BOARD_WIDTH - UNIT_SIZE;
        if (head.x >= BOARD_WIDTH) head.x = 0;
        if (head.y < 0) head.y = BOARD_HEIGHT - UNIT_SIZE;
        if (head.y >= BOARD_HEIGHT) head.y = 0;
      }

      snake.push(head);

      if (!checkFood()) {
        snake.shift();
      }
    }

    function checkCollision() {
      const head = snake[snake.length - 1];

      // æ— æ•Œæ¨¡å¼ï¼šä¸æ£€æŸ¥ç¢°æ’
      if (godMode) {
        return false;
      }

      // æ£€æŸ¥å¢™å£ç¢°æ’
      if (head.x < 0 || head.x >= BOARD_WIDTH || head.y < 0 || head.y >= BOARD_HEIGHT) {
        return true;
      }

      // æ£€æŸ¥è‡ªèº«ç¢°æ’
      for (let i = 0; i < snake.length - 1; i++) {
        if (snake[i].x === head.x && snake[i].y === head.y) {
          return true;
        }
      }

      return false;
    }

    function checkFood() {
      const head = snake[snake.length - 1];
      return head.x === food.x && head.y === food.y;
    }

    function generateFood() {
      let valid = false;
      let attempts = 0;
      while (!valid && attempts < 1000) {
        food = {
          x: Math.floor(Math.random() * (BOARD_WIDTH / UNIT_SIZE)) * UNIT_SIZE,
          y: Math.floor(Math.random() * (BOARD_HEIGHT / UNIT_SIZE)) * UNIT_SIZE
        };

        valid = true;
        for (let segment of snake) {
          if (segment.x === food.x && segment.y === food.y) {
            valid = false;
            break;
          }
        }
        attempts++;
      }
    }

    function draw() {
      // æ¸…ç©ºç”»å¸ƒ
      ctx.fillStyle = godMode ? '#0d1117' : '#0f172a';
      ctx.fillRect(0, 0, BOARD_WIDTH, BOARD_HEIGHT);

      // ç»˜åˆ¶ç½‘æ ¼
      ctx.strokeStyle = godMode ? '#1f1f3a' : '#1e293b';
      ctx.lineWidth = 1;
      for (let i = 0; i <= BOARD_WIDTH / UNIT_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * UNIT_SIZE, 0);
        ctx.lineTo(i * UNIT_SIZE, BOARD_HEIGHT);
        ctx.stroke();
      }
      for (let i = 0; i <= BOARD_HEIGHT / UNIT_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * UNIT_SIZE);
        ctx.lineTo(BOARD_WIDTH, i * UNIT_SIZE);
        ctx.stroke();
      }

      // ç»˜åˆ¶é£Ÿç‰©
      ctx.fillStyle = '#ef4444';
      ctx.beginPath();
      ctx.arc(food.x + UNIT_SIZE / 2, food.y + UNIT_SIZE / 2, UNIT_SIZE / 2 - 2, 0, Math.PI * 2);
      ctx.fill();

      // ç»˜åˆ¶è›‡
      snake.forEach((segment, index) => {
        if (index === snake.length - 1) {
          // è›‡å¤´
          if (godMode) {
            // æ— æ•Œæ¨¡å¼ï¼šæ¸å˜ç´«è‰²
            const gradient = ctx.createLinearGradient(segment.x, segment.y, segment.x + UNIT_SIZE, segment.y + UNIT_SIZE);
            gradient.addColorStop(0, '#8b5cf6');
            gradient.addColorStop(1, '#ec4899');
            ctx.fillStyle = gradient;
          } else {
            ctx.fillStyle = currentDifficulty === 'hard' ? '#ef4444' : '#10b981';
          }
          ctx.fillRect(segment.x + 1, segment.y + 1, UNIT_SIZE - 2, UNIT_SIZE - 2);
          
          // ç»˜åˆ¶çœ¼ç›
          ctx.fillStyle = '#ffffff';
          let eyeOffset = 6;
          let eyeSize = 4;
          
          if (direction === 'RIGHT') {
            ctx.fillRect(segment.x + UNIT_SIZE - eyeOffset - eyeSize, segment.y + eyeOffset, eyeSize, eyeSize);
            ctx.fillRect(segment.x + UNIT_SIZE - eyeOffset - eyeSize, segment.y + UNIT_SIZE - eyeOffset - eyeSize, eyeSize, eyeSize);
          } else if (direction === 'LEFT') {
            ctx.fillRect(segment.x + eyeOffset, segment.y + eyeOffset, eyeSize, eyeSize);
            ctx.fillRect(segment.x + eyeOffset, segment.y + UNIT_SIZE - eyeOffset - eyeSize, eyeSize, eyeSize);
          } else if (direction === 'UP') {
            ctx.fillRect(segment.x + eyeOffset, segment.y + eyeOffset, eyeSize, eyeSize);
            ctx.fillRect(segment.x + UNIT_SIZE - eyeOffset - eyeSize, segment.y + eyeOffset, eyeSize, eyeSize);
          } else if (direction === 'DOWN') {
            ctx.fillRect(segment.x + eyeOffset, segment.y + UNIT_SIZE - eyeOffset - eyeSize, eyeSize, eyeSize);
            ctx.fillRect(segment.x + UNIT_SIZE - eyeOffset - eyeSize, segment.y + UNIT_SIZE - eyeOffset - eyeSize, eyeSize, eyeSize);
          }
        } else {
          // è›‡èº«
          if (godMode) {
            // æ— æ•Œæ¨¡å¼ï¼šæ¸å˜ç´«ç²‰è‰²ï¼Œæ ¹æ®ä½ç½®å˜åŒ–
            const ratio = index / snake.length;
            ctx.fillStyle = `hsl(${280 + ratio * 40}, 70%, 60%)`;
          } else {
            ctx.fillStyle = currentDifficulty === 'hard' ? '#f87171' : '#22c55e';
          }
          ctx.fillRect(segment.x + 1, segment.y + 1, UNIT_SIZE - 2, UNIT_SIZE - 2);
        }
      });
    }

    function gameOver() {
      running = false;
      clearInterval(gameLoop);
      updateStatus('gameover');
      updateSettingsButtons(false);

      const diffSettings = DIFFICULTY_SETTINGS[currentDifficulty];
      const godModeText = godMode ? ' + æ— æ•Œ' : '';
      const titleClass = godMode ? 'overlay-title godmode' : 'overlay-title';
      
      overlay.innerHTML = `
        <div class="${titleClass}">æ¸¸æˆç»“æŸï¼</div>
        <div class="overlay-mode ${currentDifficulty}">${diffSettings.name}${godModeText}</div>
        <div class="overlay-text">æœ€ç»ˆåˆ†æ•°: ${score}</div>
        <div class="overlay-hint">æŒ‰ç©ºæ ¼é”®é‡æ–°å¼€å§‹</div>
      `;
      overlay.classList.remove('hidden');
    }

    function updateScore() {
      scoreElement.textContent = score;
    }

    function updateStatus(status) {
      statusElement.className = 'status';
      if (status === 'playing') {
        statusElement.classList.add('playing');
        statusElement.textContent = 'è¿›è¡Œä¸­';
      } else if (status === 'paused') {
        statusElement.classList.add('paused');
        statusElement.textContent = 'å·²æš‚åœ';
      } else if (status === 'gameover') {
        statusElement.classList.add('gameover');
        statusElement.textContent = 'æ¸¸æˆç»“æŸ';
      } else {
        statusElement.classList.add('playing');
        statusElement.textContent = 'å‡†å¤‡å°±ç»ª';
      }
    }

    function showOverlay(title, text, hint = '') {
      overlay.innerHTML = `
        <div class="overlay-title">${title}</div>
        <div class="overlay-text">${text}</div>
        ${hint ? `<div class="overlay-hint">${hint}</div>` : ''}
      `;
      overlay.classList.remove('hidden');
    }

    function hideOverlay() {
      overlay.classList.add('hidden');
    }

    // é”®ç›˜äº‹ä»¶ç›‘å¬
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        e.preventDefault();
        if (!running) {
          if (gameStarted && score >= 0) {
            restartGame();
            startGame();
          } else {
            startGame();
          }
        } else if (paused) {
          startGame();
        } else {
          pauseGame();
        }
        return;
      }

      if (!running || paused) return;

      // æ–¹å‘é”®æ§åˆ¶
      switch (e.code) {
        case 'ArrowUp':
        case 'KeyW':
          e.preventDefault();
          if (direction !== 'DOWN') nextDirection = 'UP';
          break;
        case 'ArrowDown':
        case 'KeyS':
          e.preventDefault();
          if (direction !== 'UP') nextDirection = 'DOWN';
          break;
        case 'ArrowLeft':
        case 'KeyA':
          e.preventDefault();
          if (direction !== 'RIGHT') nextDirection = 'LEFT';
          break;
        case 'ArrowRight':
        case 'KeyD':
          e.preventDefault();
          if (direction !== 'LEFT') nextDirection = 'RIGHT';
          break;
      }
    });

    // åˆå§‹åŒ–æ¸¸æˆ
    init();
  </script>
</body>
</html>
